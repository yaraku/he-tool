name: Backend CI

on:
  pull_request:
    paths:
      - 'backend/**'
      - '.github/workflows/backend-ci.yml'
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: write
  checks: write

env:
  POETRY_VERSION: 1.7.1
  PIP_CACHE_DIR: ~/.cache/pip

defaults:
  run:
    shell: bash

jobs:
  lint:
    name: Lint & Format
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install Poetry
        run: |
          pip install --upgrade "poetry==${POETRY_VERSION}"
          poetry config virtualenvs.create false

      - name: Install dependencies
        working-directory: backend
        run: poetry install --with dev --no-interaction --no-root

      - name: Run Black (check mode)
        working-directory: backend
        run: poetry run black --check src tests

      - name: Run isort (check mode)
        working-directory: backend
        run: poetry run isort --check-only src tests

      - name: Run Flake8
        working-directory: backend
        run: poetry run flake8 src tests

  mypy:
    name: Static Typing
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install Poetry
        run: |
          pip install --upgrade "poetry==${POETRY_VERSION}"
          poetry config virtualenvs.create false

      - name: Install dependencies
        working-directory: backend
        run: poetry install --with dev --no-interaction --no-root

      - name: Run mypy
        working-directory: backend
        run: poetry run mypy src tests

  tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.10']
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install Poetry
        run: |
          pip install --upgrade "poetry==${POETRY_VERSION}"
          poetry config virtualenvs.create false

      - name: Install dependencies
        working-directory: backend
        run: poetry install --with dev --no-interaction --no-root

      - name: Run pytest
        working-directory: backend
        run: >-
          poetry run pytest
          --junitxml=pytest-results.xml
          --cov=human_evaluation_tool
          --cov-report=term-missing
          --cov-report=xml

      - name: Upload coverage report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.python-version }}
          path: |
            backend/.coverage
            backend/coverage.xml
          if-no-files-found: ignore

      - name: Upload pytest results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: pytest-results-${{ matrix.python-version }}
          path: backend/pytest-results.xml

      - name: Publish Unit Test Results
        if: ${{ always() && github.event_name == 'pull_request' }}
        uses: EnricoMi/publish-unit-test-result-action/linux@v2
        with:
          files: backend/pytest-results.xml

      - name: Summarize coverage
        if: always()
        id: coverage_summary
        working-directory: backend
        run: |
          python - <<'PY'
          import os
          from pathlib import Path
          import xml.etree.ElementTree as ET

          coverage_file = Path("coverage.xml")
          output_file = Path(os.environ["GITHUB_OUTPUT"])

          if not coverage_file.exists():
              print("::warning::Coverage file not found; skipping summary generation.")
              with output_file.open("w", encoding="utf-8") as fh:
                  fh.write("line_coverage=\n")
                  fh.write("branch_coverage=\n")
              raise SystemExit(0)

          root = ET.parse(coverage_file).getroot()
          line_rate = float(root.attrib.get("line-rate", "0")) * 100
          branch_attr = root.attrib.get("branch-rate")
          branch_rate = f"{float(branch_attr) * 100:.2f}" if branch_attr is not None else ""

          summary_lines = [
              f"Total line coverage: {line_rate:.2f}%",
          ]
          if branch_rate:
              summary_lines.append(f"Total branch coverage: {branch_rate}%")

          print("\n".join(summary_lines))

          with output_file.open("w", encoding="utf-8") as fh:
              fh.write(f"line_coverage={line_rate:.2f}\n")
              fh.write(f"branch_coverage={branch_rate}\n")
          PY

      - name: Comment coverage on PR
        if: ${{ github.event_name == 'pull_request' && steps.coverage_summary.outputs.line_coverage != '' }}
        uses: actions/github-script@v7
        env:
          LINE_COVERAGE: ${{ steps.coverage_summary.outputs.line_coverage }}
          BRANCH_COVERAGE: ${{ steps.coverage_summary.outputs.branch_coverage }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const header = '## ðŸ§ª Coverage Report';
            const lineCoverage = Number(process.env.LINE_COVERAGE).toFixed(2);
            const branchCoverageRaw = process.env.BRANCH_COVERAGE;
            const hasBranch = branchCoverageRaw !== undefined && branchCoverageRaw !== '';
            const branchCoverage = hasBranch ? Number(branchCoverageRaw).toFixed(2) : null;

            let body = `${header}\n\n| Metric | Coverage |\n| --- | --- |\n| Line | ${lineCoverage}% |`;
            if (hasBranch && branchCoverage !== null && !Number.isNaN(Number(branchCoverage))) {
              body += `\n| Branch | ${branchCoverage}% |`;
            }
            body += '\n\n_Reported by coverage.py_';

            const { owner, repo } = context.repo;
            const issue_number = context.issue.number;
            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number,
              per_page: 100,
            });

            const existingComment = comments.find((comment) => comment.body && comment.body.startsWith(header));

            if (existingComment) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existingComment.id,
                body,
              });
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body,
              });
            }
